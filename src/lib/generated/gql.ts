/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
    "query GetAppGlobalPollingData {\n  tokenGetCurrentPrices {\n    price\n    address\n  }\n  protocolMetricsChain {\n    totalLiquidity\n    poolCount\n    swapFee24h\n    swapVolume24h\n  }\n  blocksGetBlocksPerDay\n  blocksGetAverageBlockTime\n}\n\nquery GetTokens($chains: [GqlChain!]!) {\n  tokens: tokenGetTokens(chains: $chains) {\n    address\n    name\n    symbol\n    decimals\n    chain\n    chainId\n    logoURI\n    priority\n    tradable\n    isErc4626\n    isBufferAllowed\n    coingeckoId\n  }\n}\n\nquery GetTokenPrices($chains: [GqlChain!]!) {\n  tokenPrices: tokenGetCurrentPrices(chains: $chains) {\n    price\n    address\n    chain\n    updatedAt\n  }\n}\n\nquery GetTokensDynamicData($addresses: [String!]!) {\n  dynamicData: tokenGetTokensDynamicData(addresses: $addresses) {\n    ath\n    atl\n    fdv\n    high24h\n    id\n    low24h\n    marketCap\n    price\n    priceChange24h\n    priceChangePercent7d\n    priceChangePercent14d\n    priceChangePercent24h\n    priceChangePercent30d\n    tokenAddress\n    updatedAt\n  }\n}\n\nquery GetBlocksPerDay {\n  blocksPerDay: blocksGetBlocksPerDay\n  avgBlockTime: blocksGetAverageBlockTime\n}": typeof types.GetAppGlobalPollingDataDocument,
    "fragment Hook on GqlHook {\n  address\n  config {\n    enableHookAdjustedAmounts\n    shouldCallAfterAddLiquidity\n    shouldCallAfterInitialize\n    shouldCallAfterRemoveLiquidity\n    shouldCallAfterSwap\n    shouldCallBeforeAddLiquidity\n    shouldCallBeforeInitialize\n    shouldCallBeforeRemoveLiquidity\n    shouldCallBeforeSwap\n    shouldCallComputeDynamicSwapFee\n  }\n  type\n  params {\n    ... on ExitFeeHookParams {\n      exitFeePercentage\n    }\n    ... on FeeTakingHookParams {\n      addLiquidityFeePercentage\n      removeLiquidityFeePercentage\n      swapFeePercentage\n    }\n    ... on StableSurgeHookParams {\n      maxSurgeFeePercentage\n      surgeThresholdPercentage\n    }\n    ... on MevTaxHookParams {\n      mevTaxThreshold\n      mevTaxMultiplier\n      maxMevSwapFeePercentage\n    }\n  }\n  reviewData {\n    reviewFile\n    summary\n    warnings\n  }\n}": typeof types.HookFragmentDoc,
    "fragment UnderlyingToken on GqlToken {\n  chain\n  chainId\n  address\n  decimals\n  name\n  symbol\n  priority\n  tradable\n  isErc4626\n  logoURI\n}\n\nfragment Erc4626ReviewData on Erc4626ReviewData {\n  reviewFile\n  summary\n  warnings\n}\n\nfragment PoolTokens on GqlPoolTokenDetail {\n  id\n  chain\n  chainId\n  address\n  decimals\n  name\n  symbol\n  priority\n  tradable\n  canUseBufferForSwaps\n  useWrappedForAddRemove\n  useUnderlyingForAddRemove\n  index\n  balance\n  balanceUSD\n  priceRate\n  decimals\n  weight\n  hasNestedPool\n  isAllowed\n  priceRateProvider\n  logoURI\n  priceRateProviderData {\n    address\n    name\n    summary\n    reviewed\n    warnings\n    upgradeableComponents {\n      entryPoint\n      implementationReviewed\n    }\n    reviewFile\n    factory\n  }\n  nestedPool {\n    id\n    address\n    type\n    bptPriceRate\n    nestedPercentage\n    nestedShares\n    totalLiquidity\n    totalShares\n    tokens {\n      index\n      address\n      decimals\n      balance\n      balanceUSD\n      symbol\n      weight\n      isErc4626\n      canUseBufferForSwaps\n      useWrappedForAddRemove\n      useUnderlyingForAddRemove\n      logoURI\n      underlyingToken {\n        ...UnderlyingToken\n      }\n      erc4626ReviewData {\n        ...Erc4626ReviewData\n      }\n    }\n    hook {\n      ...Hook\n    }\n  }\n  isErc4626\n  isBufferAllowed\n  underlyingToken {\n    ...UnderlyingToken\n  }\n  erc4626ReviewData {\n    ...Erc4626ReviewData\n  }\n}": typeof types.UnderlyingTokenFragmentDoc,
    "query GetPool($id: String!, $chain: GqlChain!, $userAddress: String) {\n  pool: poolGetPool(id: $id, chain: $chain, userAddress: $userAddress) {\n    id\n    address\n    name\n    version\n    owner\n    swapFeeManager\n    pauseManager\n    poolCreator\n    decimals\n    factory\n    symbol\n    createTime\n    type\n    chain\n    protocolVersion\n    tags\n    hasErc4626\n    hasNestedErc4626\n    liquidityManagement {\n      disableUnbalancedLiquidity\n    }\n    hook {\n      ...Hook\n    }\n    dynamicData {\n      poolId\n      swapEnabled\n      totalLiquidity\n      totalShares\n      fees24h\n      surplus24h\n      swapFee\n      volume24h\n      holdersCount\n      isInRecoveryMode\n      isPaused\n      aprItems {\n        id\n        title\n        apr\n        type\n        rewardTokenSymbol\n        rewardTokenAddress\n      }\n    }\n    staking {\n      id\n      type\n      chain\n      address\n      gauge {\n        id\n        gaugeAddress\n        version\n        status\n        workingSupply\n        otherGauges {\n          gaugeAddress\n          version\n          status\n          id\n          rewards {\n            id\n            tokenAddress\n            rewardPerSecond\n          }\n        }\n        rewards {\n          id\n          rewardPerSecond\n          tokenAddress\n        }\n      }\n      aura {\n        id\n        apr\n        auraPoolAddress\n        auraPoolId\n        isShutdown\n      }\n    }\n    userBalance {\n      totalBalance\n      totalBalanceUsd\n      walletBalance\n      walletBalanceUsd\n      stakedBalances {\n        balance\n        balanceUsd\n        stakingType\n        stakingId\n      }\n    }\n    ... on GqlPoolWeighted {\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolStable {\n      amp\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolMetaStable {\n      amp\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolElement {\n      unitSeconds\n      principalToken\n      baseToken\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolComposableStable {\n      amp\n      nestingType\n      bptPriceRate\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolLiquidityBootstrapping {\n      name\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolGyro {\n      alpha\n      beta\n      type\n      c\n      dSq\n      lambda\n      root3Alpha\n      s\n      sqrtAlpha\n      sqrtBeta\n      tauAlphaX\n      tauAlphaY\n      tauBetaX\n      tauBetaY\n      u\n      v\n      w\n      z\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolFx {\n      alpha\n      beta\n      delta\n      epsilon\n      lambda\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolQuantAmmWeighted {\n      hasAnyAllowedBuffer\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolReClamm {\n      hasAnyAllowedBuffer\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n  }\n}\n\nquery GetPoolSnapshots($poolId: String!, $range: GqlPoolSnapshotDataRange!, $chainId: GqlChain!) {\n  snapshots: poolGetSnapshots(id: $poolId, range: $range, chain: $chainId) {\n    id\n    timestamp\n    totalLiquidity\n    volume24h\n    fees24h\n    surplus24h\n    sharePrice\n  }\n}\n\nquery GetPoolTokensDynamicData($addresses: [String!]!) {\n  staticData: tokenGetTokensData(addresses: $addresses) {\n    id\n    tokenAddress\n    description\n    discordUrl\n    telegramUrl\n    twitterUsername\n    websiteUrl\n  }\n  dynamicData: tokenGetTokensDynamicData(addresses: $addresses) {\n    ...GqlTokenDynamicData\n  }\n}\n\nquery GetPoolEvents($first: Int, $skip: Int, $poolIdIn: [String!]!, $chainIn: [GqlChain!]!, $range: GqlPoolEventsDataRange, $typeIn: [GqlPoolEventType], $userAddress: String) {\n  poolEvents(\n    first: $first\n    skip: $skip\n    where: {poolIdIn: $poolIdIn, chainIn: $chainIn, range: $range, typeIn: $typeIn, userAddress: $userAddress}\n  ) {\n    id\n    poolId\n    timestamp\n    tx\n    type\n    valueUSD\n    chain\n    userAddress\n    ... on GqlPoolSwapEventV3 {\n      tokenIn {\n        address\n        amount\n      }\n      tokenOut {\n        address\n        amount\n      }\n    }\n    ... on GqlPoolSwapEventCowAmm {\n      tokenIn {\n        address\n        amount\n        valueUSD\n      }\n      tokenOut {\n        address\n        amount\n        valueUSD\n      }\n      surplus {\n        address\n        amount\n        valueUSD\n      }\n    }\n    ... on GqlPoolAddRemoveEventV3 {\n      tokens {\n        address\n        amount\n        valueUSD\n      }\n    }\n  }\n}": typeof types.GetPoolDocument,
    "query GetPools($first: Int, $skip: Int, $orderBy: GqlPoolOrderBy, $orderDirection: GqlPoolOrderDirection, $where: GqlPoolFilter, $textSearch: String) {\n  pools: poolGetPools(\n    first: $first\n    skip: $skip\n    orderBy: $orderBy\n    orderDirection: $orderDirection\n    where: $where\n    textSearch: $textSearch\n  ) {\n    address\n    chain\n    createTime\n    decimals\n    protocolVersion\n    tags\n    hasErc4626\n    hasNestedErc4626\n    hook {\n      ...Hook\n    }\n    poolTokens {\n      id\n      address\n      symbol\n      weight\n      name\n      canUseBufferForSwaps\n      useWrappedForAddRemove\n      useUnderlyingForAddRemove\n      nestedPool {\n        id\n        address\n        symbol\n        name\n        tokens {\n          id\n          address\n          symbol\n          weight\n          name\n          canUseBufferForSwaps\n          useWrappedForAddRemove\n          useUnderlyingForAddRemove\n        }\n      }\n    }\n    dynamicData {\n      totalLiquidity\n      lifetimeVolume\n      lifetimeSwapFees\n      volume24h\n      fees24h\n      holdersCount\n      swapFee\n      swapsCount\n      totalShares\n      aprItems {\n        id\n        title\n        apr\n        type\n        rewardTokenSymbol\n        rewardTokenAddress\n      }\n    }\n    staking {\n      id\n      type\n      chain\n      address\n      gauge {\n        id\n        gaugeAddress\n        version\n        status\n        workingSupply\n        otherGauges {\n          gaugeAddress\n          version\n          status\n          id\n          rewards {\n            id\n            tokenAddress\n            rewardPerSecond\n          }\n        }\n        rewards {\n          id\n          rewardPerSecond\n          tokenAddress\n        }\n      }\n      aura {\n        id\n        apr\n        auraPoolAddress\n        auraPoolId\n        isShutdown\n      }\n    }\n    factory\n    id\n    name\n    owner\n    swapFeeManager\n    pauseManager\n    poolCreator\n    symbol\n    type\n    userBalance {\n      totalBalance\n      totalBalanceUsd\n      walletBalance\n      walletBalanceUsd\n      stakedBalances {\n        balance\n        balanceUsd\n        stakingType\n        stakingId\n      }\n    }\n    poolTokens {\n      ...PoolTokens\n    }\n  }\n  count: poolGetPoolsCount(\n    first: $first\n    skip: $skip\n    orderBy: $orderBy\n    orderDirection: $orderDirection\n    where: $where\n    textSearch: $textSearch\n  )\n}\n\nquery GetFeaturedPools($chains: [GqlChain!]!) {\n  featuredPools: poolGetFeaturedPools(chains: $chains) {\n    poolId\n    primary\n    description\n    pool {\n      address\n      id\n      name\n      factory\n      symbol\n      type\n      chain\n      protocolVersion\n      dynamicData {\n        totalLiquidity\n        aprItems {\n          id\n          title\n          apr\n          type\n          rewardTokenSymbol\n          rewardTokenAddress\n        }\n      }\n      poolTokens {\n        ...PoolTokens\n      }\n      hasErc4626\n      hasNestedErc4626\n    }\n  }\n}": typeof types.GetPoolsDocument,
    "query GetProtocolStats($chains: [GqlChain!]) {\n  protocolMetricsAggregated(chains: $chains) {\n    totalLiquidity\n    numLiquidityProviders\n    swapVolume24h\n    swapFee24h\n    yieldCapture24h\n    poolCount\n    yieldCapture24h\n    surplus24h\n  }\n}\n\nquery GetProtocolStatsPerChain($chain: GqlChain) {\n  protocolMetricsChain(chain: $chain) {\n    chainId\n    numLiquidityProviders\n    poolCount\n    swapFee24h\n    swapVolume24h\n    totalLiquidity\n    yieldCapture24h\n    surplus24h\n  }\n}": typeof types.GetProtocolStatsDocument,
    "query GetReliquaryFarmSnapshots($id: String!, $range: GqlPoolSnapshotDataRange!) {\n  snapshots: beetsPoolGetReliquaryFarmSnapshots(id: $id, range: $range) {\n    id\n    farmId\n    timestamp\n    totalBalance\n    totalLiquidity\n    levelBalances {\n      id\n      level\n      balance\n    }\n    relicCount\n    totalBalance\n    userCount\n    tokenBalances {\n      id\n      address\n      balance\n      symbol\n    }\n  }\n}": typeof types.GetReliquaryFarmSnapshotsDocument,
    "query GetStakedSonicData {\n  stsGetGqlStakedSonicData {\n    delegatedValidators {\n      assetsDelegated\n      validatorId\n    }\n    exchangeRate\n    stakingApr\n    totalAssets\n    totalAssetsDelegated\n    totalAssetsPool\n    rewardsClaimed24h\n  }\n}": typeof types.GetStakedSonicDataDocument,
    "query SorGetSwapPaths($tokenIn: String!, $tokenOut: String!, $swapType: GqlSorSwapType!, $swapAmount: AmountHumanReadable!, $chain: GqlChain!, $poolIds: [String!]) {\n  swaps: sorGetSwapPaths(\n    tokenIn: $tokenIn\n    tokenOut: $tokenOut\n    swapType: $swapType\n    swapAmount: $swapAmount\n    chain: $chain\n    poolIds: $poolIds\n    considerPoolsWithHooks: true\n  ) {\n    effectivePrice\n    effectivePriceReversed\n    swapType\n    paths {\n      inputAmountRaw\n      outputAmountRaw\n      pools\n      isBuffer\n      protocolVersion\n      tokens {\n        address\n        decimals\n      }\n    }\n    priceImpact {\n      priceImpact\n      error\n    }\n    returnAmount\n    routes {\n      hops {\n        poolId\n        tokenIn\n        tokenInAmount\n        tokenOut\n        tokenOutAmount\n      }\n      share\n      tokenInAmount\n      tokenInAmount\n      tokenOut\n      tokenOutAmount\n    }\n    swapAmount\n    swaps {\n      amount\n      assetInIndex\n      assetOutIndex\n      poolId\n      userData\n    }\n    tokenIn\n    tokenInAmount\n    tokenOut\n    tokenOutAmount\n    protocolVersion\n  }\n}\n\nfragment GqlTokenDynamicData on GqlTokenDynamicData {\n  id\n  tokenAddress\n  ath\n  atl\n  marketCap\n  fdv\n  priceChange24h\n  priceChangePercent24h\n  priceChangePercent7d\n  priceChangePercent14d\n  priceChangePercent30d\n  high24h\n  low24h\n  updatedAt\n}": typeof types.SorGetSwapPathsDocument,
    "query GetVeBalUser($address: String!, $chain: GqlChain) {\n  veBalGetUser(address: $address, chain: $chain) {\n    balance\n    rank\n    lockSnapshots {\n      balance\n      timestamp\n      bias\n      slope\n    }\n  }\n}": typeof types.GetVeBalUserDocument,
    "query GetVeBalVotingList($includeKilled: Boolean) {\n  veBalGetVotingList(includeKilled: $includeKilled) {\n    id\n    symbol\n    type\n    address\n    chain\n    protocolVersion\n    gauge {\n      addedTimestamp\n      address\n      childGaugeAddress\n      isKilled\n      relativeWeight\n      relativeWeightCap\n    }\n    poolTokens {\n      ...PoolTokens\n    }\n    tags\n  }\n}": typeof types.GetVeBalVotingListDocument,
};
const documents: Documents = {
    "query GetAppGlobalPollingData {\n  tokenGetCurrentPrices {\n    price\n    address\n  }\n  protocolMetricsChain {\n    totalLiquidity\n    poolCount\n    swapFee24h\n    swapVolume24h\n  }\n  blocksGetBlocksPerDay\n  blocksGetAverageBlockTime\n}\n\nquery GetTokens($chains: [GqlChain!]!) {\n  tokens: tokenGetTokens(chains: $chains) {\n    address\n    name\n    symbol\n    decimals\n    chain\n    chainId\n    logoURI\n    priority\n    tradable\n    isErc4626\n    isBufferAllowed\n    coingeckoId\n  }\n}\n\nquery GetTokenPrices($chains: [GqlChain!]!) {\n  tokenPrices: tokenGetCurrentPrices(chains: $chains) {\n    price\n    address\n    chain\n    updatedAt\n  }\n}\n\nquery GetTokensDynamicData($addresses: [String!]!) {\n  dynamicData: tokenGetTokensDynamicData(addresses: $addresses) {\n    ath\n    atl\n    fdv\n    high24h\n    id\n    low24h\n    marketCap\n    price\n    priceChange24h\n    priceChangePercent7d\n    priceChangePercent14d\n    priceChangePercent24h\n    priceChangePercent30d\n    tokenAddress\n    updatedAt\n  }\n}\n\nquery GetBlocksPerDay {\n  blocksPerDay: blocksGetBlocksPerDay\n  avgBlockTime: blocksGetAverageBlockTime\n}": types.GetAppGlobalPollingDataDocument,
    "fragment Hook on GqlHook {\n  address\n  config {\n    enableHookAdjustedAmounts\n    shouldCallAfterAddLiquidity\n    shouldCallAfterInitialize\n    shouldCallAfterRemoveLiquidity\n    shouldCallAfterSwap\n    shouldCallBeforeAddLiquidity\n    shouldCallBeforeInitialize\n    shouldCallBeforeRemoveLiquidity\n    shouldCallBeforeSwap\n    shouldCallComputeDynamicSwapFee\n  }\n  type\n  params {\n    ... on ExitFeeHookParams {\n      exitFeePercentage\n    }\n    ... on FeeTakingHookParams {\n      addLiquidityFeePercentage\n      removeLiquidityFeePercentage\n      swapFeePercentage\n    }\n    ... on StableSurgeHookParams {\n      maxSurgeFeePercentage\n      surgeThresholdPercentage\n    }\n    ... on MevTaxHookParams {\n      mevTaxThreshold\n      mevTaxMultiplier\n      maxMevSwapFeePercentage\n    }\n  }\n  reviewData {\n    reviewFile\n    summary\n    warnings\n  }\n}": types.HookFragmentDoc,
    "fragment UnderlyingToken on GqlToken {\n  chain\n  chainId\n  address\n  decimals\n  name\n  symbol\n  priority\n  tradable\n  isErc4626\n  logoURI\n}\n\nfragment Erc4626ReviewData on Erc4626ReviewData {\n  reviewFile\n  summary\n  warnings\n}\n\nfragment PoolTokens on GqlPoolTokenDetail {\n  id\n  chain\n  chainId\n  address\n  decimals\n  name\n  symbol\n  priority\n  tradable\n  canUseBufferForSwaps\n  useWrappedForAddRemove\n  useUnderlyingForAddRemove\n  index\n  balance\n  balanceUSD\n  priceRate\n  decimals\n  weight\n  hasNestedPool\n  isAllowed\n  priceRateProvider\n  logoURI\n  priceRateProviderData {\n    address\n    name\n    summary\n    reviewed\n    warnings\n    upgradeableComponents {\n      entryPoint\n      implementationReviewed\n    }\n    reviewFile\n    factory\n  }\n  nestedPool {\n    id\n    address\n    type\n    bptPriceRate\n    nestedPercentage\n    nestedShares\n    totalLiquidity\n    totalShares\n    tokens {\n      index\n      address\n      decimals\n      balance\n      balanceUSD\n      symbol\n      weight\n      isErc4626\n      canUseBufferForSwaps\n      useWrappedForAddRemove\n      useUnderlyingForAddRemove\n      logoURI\n      underlyingToken {\n        ...UnderlyingToken\n      }\n      erc4626ReviewData {\n        ...Erc4626ReviewData\n      }\n    }\n    hook {\n      ...Hook\n    }\n  }\n  isErc4626\n  isBufferAllowed\n  underlyingToken {\n    ...UnderlyingToken\n  }\n  erc4626ReviewData {\n    ...Erc4626ReviewData\n  }\n}": types.UnderlyingTokenFragmentDoc,
    "query GetPool($id: String!, $chain: GqlChain!, $userAddress: String) {\n  pool: poolGetPool(id: $id, chain: $chain, userAddress: $userAddress) {\n    id\n    address\n    name\n    version\n    owner\n    swapFeeManager\n    pauseManager\n    poolCreator\n    decimals\n    factory\n    symbol\n    createTime\n    type\n    chain\n    protocolVersion\n    tags\n    hasErc4626\n    hasNestedErc4626\n    liquidityManagement {\n      disableUnbalancedLiquidity\n    }\n    hook {\n      ...Hook\n    }\n    dynamicData {\n      poolId\n      swapEnabled\n      totalLiquidity\n      totalShares\n      fees24h\n      surplus24h\n      swapFee\n      volume24h\n      holdersCount\n      isInRecoveryMode\n      isPaused\n      aprItems {\n        id\n        title\n        apr\n        type\n        rewardTokenSymbol\n        rewardTokenAddress\n      }\n    }\n    staking {\n      id\n      type\n      chain\n      address\n      gauge {\n        id\n        gaugeAddress\n        version\n        status\n        workingSupply\n        otherGauges {\n          gaugeAddress\n          version\n          status\n          id\n          rewards {\n            id\n            tokenAddress\n            rewardPerSecond\n          }\n        }\n        rewards {\n          id\n          rewardPerSecond\n          tokenAddress\n        }\n      }\n      aura {\n        id\n        apr\n        auraPoolAddress\n        auraPoolId\n        isShutdown\n      }\n    }\n    userBalance {\n      totalBalance\n      totalBalanceUsd\n      walletBalance\n      walletBalanceUsd\n      stakedBalances {\n        balance\n        balanceUsd\n        stakingType\n        stakingId\n      }\n    }\n    ... on GqlPoolWeighted {\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolStable {\n      amp\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolMetaStable {\n      amp\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolElement {\n      unitSeconds\n      principalToken\n      baseToken\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolComposableStable {\n      amp\n      nestingType\n      bptPriceRate\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolLiquidityBootstrapping {\n      name\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolGyro {\n      alpha\n      beta\n      type\n      c\n      dSq\n      lambda\n      root3Alpha\n      s\n      sqrtAlpha\n      sqrtBeta\n      tauAlphaX\n      tauAlphaY\n      tauBetaX\n      tauBetaY\n      u\n      v\n      w\n      z\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolFx {\n      alpha\n      beta\n      delta\n      epsilon\n      lambda\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolQuantAmmWeighted {\n      hasAnyAllowedBuffer\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolReClamm {\n      hasAnyAllowedBuffer\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n  }\n}\n\nquery GetPoolSnapshots($poolId: String!, $range: GqlPoolSnapshotDataRange!, $chainId: GqlChain!) {\n  snapshots: poolGetSnapshots(id: $poolId, range: $range, chain: $chainId) {\n    id\n    timestamp\n    totalLiquidity\n    volume24h\n    fees24h\n    surplus24h\n    sharePrice\n  }\n}\n\nquery GetPoolTokensDynamicData($addresses: [String!]!) {\n  staticData: tokenGetTokensData(addresses: $addresses) {\n    id\n    tokenAddress\n    description\n    discordUrl\n    telegramUrl\n    twitterUsername\n    websiteUrl\n  }\n  dynamicData: tokenGetTokensDynamicData(addresses: $addresses) {\n    ...GqlTokenDynamicData\n  }\n}\n\nquery GetPoolEvents($first: Int, $skip: Int, $poolIdIn: [String!]!, $chainIn: [GqlChain!]!, $range: GqlPoolEventsDataRange, $typeIn: [GqlPoolEventType], $userAddress: String) {\n  poolEvents(\n    first: $first\n    skip: $skip\n    where: {poolIdIn: $poolIdIn, chainIn: $chainIn, range: $range, typeIn: $typeIn, userAddress: $userAddress}\n  ) {\n    id\n    poolId\n    timestamp\n    tx\n    type\n    valueUSD\n    chain\n    userAddress\n    ... on GqlPoolSwapEventV3 {\n      tokenIn {\n        address\n        amount\n      }\n      tokenOut {\n        address\n        amount\n      }\n    }\n    ... on GqlPoolSwapEventCowAmm {\n      tokenIn {\n        address\n        amount\n        valueUSD\n      }\n      tokenOut {\n        address\n        amount\n        valueUSD\n      }\n      surplus {\n        address\n        amount\n        valueUSD\n      }\n    }\n    ... on GqlPoolAddRemoveEventV3 {\n      tokens {\n        address\n        amount\n        valueUSD\n      }\n    }\n  }\n}": types.GetPoolDocument,
    "query GetPools($first: Int, $skip: Int, $orderBy: GqlPoolOrderBy, $orderDirection: GqlPoolOrderDirection, $where: GqlPoolFilter, $textSearch: String) {\n  pools: poolGetPools(\n    first: $first\n    skip: $skip\n    orderBy: $orderBy\n    orderDirection: $orderDirection\n    where: $where\n    textSearch: $textSearch\n  ) {\n    address\n    chain\n    createTime\n    decimals\n    protocolVersion\n    tags\n    hasErc4626\n    hasNestedErc4626\n    hook {\n      ...Hook\n    }\n    poolTokens {\n      id\n      address\n      symbol\n      weight\n      name\n      canUseBufferForSwaps\n      useWrappedForAddRemove\n      useUnderlyingForAddRemove\n      nestedPool {\n        id\n        address\n        symbol\n        name\n        tokens {\n          id\n          address\n          symbol\n          weight\n          name\n          canUseBufferForSwaps\n          useWrappedForAddRemove\n          useUnderlyingForAddRemove\n        }\n      }\n    }\n    dynamicData {\n      totalLiquidity\n      lifetimeVolume\n      lifetimeSwapFees\n      volume24h\n      fees24h\n      holdersCount\n      swapFee\n      swapsCount\n      totalShares\n      aprItems {\n        id\n        title\n        apr\n        type\n        rewardTokenSymbol\n        rewardTokenAddress\n      }\n    }\n    staking {\n      id\n      type\n      chain\n      address\n      gauge {\n        id\n        gaugeAddress\n        version\n        status\n        workingSupply\n        otherGauges {\n          gaugeAddress\n          version\n          status\n          id\n          rewards {\n            id\n            tokenAddress\n            rewardPerSecond\n          }\n        }\n        rewards {\n          id\n          rewardPerSecond\n          tokenAddress\n        }\n      }\n      aura {\n        id\n        apr\n        auraPoolAddress\n        auraPoolId\n        isShutdown\n      }\n    }\n    factory\n    id\n    name\n    owner\n    swapFeeManager\n    pauseManager\n    poolCreator\n    symbol\n    type\n    userBalance {\n      totalBalance\n      totalBalanceUsd\n      walletBalance\n      walletBalanceUsd\n      stakedBalances {\n        balance\n        balanceUsd\n        stakingType\n        stakingId\n      }\n    }\n    poolTokens {\n      ...PoolTokens\n    }\n  }\n  count: poolGetPoolsCount(\n    first: $first\n    skip: $skip\n    orderBy: $orderBy\n    orderDirection: $orderDirection\n    where: $where\n    textSearch: $textSearch\n  )\n}\n\nquery GetFeaturedPools($chains: [GqlChain!]!) {\n  featuredPools: poolGetFeaturedPools(chains: $chains) {\n    poolId\n    primary\n    description\n    pool {\n      address\n      id\n      name\n      factory\n      symbol\n      type\n      chain\n      protocolVersion\n      dynamicData {\n        totalLiquidity\n        aprItems {\n          id\n          title\n          apr\n          type\n          rewardTokenSymbol\n          rewardTokenAddress\n        }\n      }\n      poolTokens {\n        ...PoolTokens\n      }\n      hasErc4626\n      hasNestedErc4626\n    }\n  }\n}": types.GetPoolsDocument,
    "query GetProtocolStats($chains: [GqlChain!]) {\n  protocolMetricsAggregated(chains: $chains) {\n    totalLiquidity\n    numLiquidityProviders\n    swapVolume24h\n    swapFee24h\n    yieldCapture24h\n    poolCount\n    yieldCapture24h\n    surplus24h\n  }\n}\n\nquery GetProtocolStatsPerChain($chain: GqlChain) {\n  protocolMetricsChain(chain: $chain) {\n    chainId\n    numLiquidityProviders\n    poolCount\n    swapFee24h\n    swapVolume24h\n    totalLiquidity\n    yieldCapture24h\n    surplus24h\n  }\n}": types.GetProtocolStatsDocument,
    "query GetReliquaryFarmSnapshots($id: String!, $range: GqlPoolSnapshotDataRange!) {\n  snapshots: beetsPoolGetReliquaryFarmSnapshots(id: $id, range: $range) {\n    id\n    farmId\n    timestamp\n    totalBalance\n    totalLiquidity\n    levelBalances {\n      id\n      level\n      balance\n    }\n    relicCount\n    totalBalance\n    userCount\n    tokenBalances {\n      id\n      address\n      balance\n      symbol\n    }\n  }\n}": types.GetReliquaryFarmSnapshotsDocument,
    "query GetStakedSonicData {\n  stsGetGqlStakedSonicData {\n    delegatedValidators {\n      assetsDelegated\n      validatorId\n    }\n    exchangeRate\n    stakingApr\n    totalAssets\n    totalAssetsDelegated\n    totalAssetsPool\n    rewardsClaimed24h\n  }\n}": types.GetStakedSonicDataDocument,
    "query SorGetSwapPaths($tokenIn: String!, $tokenOut: String!, $swapType: GqlSorSwapType!, $swapAmount: AmountHumanReadable!, $chain: GqlChain!, $poolIds: [String!]) {\n  swaps: sorGetSwapPaths(\n    tokenIn: $tokenIn\n    tokenOut: $tokenOut\n    swapType: $swapType\n    swapAmount: $swapAmount\n    chain: $chain\n    poolIds: $poolIds\n    considerPoolsWithHooks: true\n  ) {\n    effectivePrice\n    effectivePriceReversed\n    swapType\n    paths {\n      inputAmountRaw\n      outputAmountRaw\n      pools\n      isBuffer\n      protocolVersion\n      tokens {\n        address\n        decimals\n      }\n    }\n    priceImpact {\n      priceImpact\n      error\n    }\n    returnAmount\n    routes {\n      hops {\n        poolId\n        tokenIn\n        tokenInAmount\n        tokenOut\n        tokenOutAmount\n      }\n      share\n      tokenInAmount\n      tokenInAmount\n      tokenOut\n      tokenOutAmount\n    }\n    swapAmount\n    swaps {\n      amount\n      assetInIndex\n      assetOutIndex\n      poolId\n      userData\n    }\n    tokenIn\n    tokenInAmount\n    tokenOut\n    tokenOutAmount\n    protocolVersion\n  }\n}\n\nfragment GqlTokenDynamicData on GqlTokenDynamicData {\n  id\n  tokenAddress\n  ath\n  atl\n  marketCap\n  fdv\n  priceChange24h\n  priceChangePercent24h\n  priceChangePercent7d\n  priceChangePercent14d\n  priceChangePercent30d\n  high24h\n  low24h\n  updatedAt\n}": types.SorGetSwapPathsDocument,
    "query GetVeBalUser($address: String!, $chain: GqlChain) {\n  veBalGetUser(address: $address, chain: $chain) {\n    balance\n    rank\n    lockSnapshots {\n      balance\n      timestamp\n      bias\n      slope\n    }\n  }\n}": types.GetVeBalUserDocument,
    "query GetVeBalVotingList($includeKilled: Boolean) {\n  veBalGetVotingList(includeKilled: $includeKilled) {\n    id\n    symbol\n    type\n    address\n    chain\n    protocolVersion\n    gauge {\n      addedTimestamp\n      address\n      childGaugeAddress\n      isKilled\n      relativeWeight\n      relativeWeightCap\n    }\n    poolTokens {\n      ...PoolTokens\n    }\n    tags\n  }\n}": types.GetVeBalVotingListDocument,
};

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = graphql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function graphql(source: string): unknown;

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetAppGlobalPollingData {\n  tokenGetCurrentPrices {\n    price\n    address\n  }\n  protocolMetricsChain {\n    totalLiquidity\n    poolCount\n    swapFee24h\n    swapVolume24h\n  }\n  blocksGetBlocksPerDay\n  blocksGetAverageBlockTime\n}\n\nquery GetTokens($chains: [GqlChain!]!) {\n  tokens: tokenGetTokens(chains: $chains) {\n    address\n    name\n    symbol\n    decimals\n    chain\n    chainId\n    logoURI\n    priority\n    tradable\n    isErc4626\n    isBufferAllowed\n    coingeckoId\n  }\n}\n\nquery GetTokenPrices($chains: [GqlChain!]!) {\n  tokenPrices: tokenGetCurrentPrices(chains: $chains) {\n    price\n    address\n    chain\n    updatedAt\n  }\n}\n\nquery GetTokensDynamicData($addresses: [String!]!) {\n  dynamicData: tokenGetTokensDynamicData(addresses: $addresses) {\n    ath\n    atl\n    fdv\n    high24h\n    id\n    low24h\n    marketCap\n    price\n    priceChange24h\n    priceChangePercent7d\n    priceChangePercent14d\n    priceChangePercent24h\n    priceChangePercent30d\n    tokenAddress\n    updatedAt\n  }\n}\n\nquery GetBlocksPerDay {\n  blocksPerDay: blocksGetBlocksPerDay\n  avgBlockTime: blocksGetAverageBlockTime\n}"): (typeof documents)["query GetAppGlobalPollingData {\n  tokenGetCurrentPrices {\n    price\n    address\n  }\n  protocolMetricsChain {\n    totalLiquidity\n    poolCount\n    swapFee24h\n    swapVolume24h\n  }\n  blocksGetBlocksPerDay\n  blocksGetAverageBlockTime\n}\n\nquery GetTokens($chains: [GqlChain!]!) {\n  tokens: tokenGetTokens(chains: $chains) {\n    address\n    name\n    symbol\n    decimals\n    chain\n    chainId\n    logoURI\n    priority\n    tradable\n    isErc4626\n    isBufferAllowed\n    coingeckoId\n  }\n}\n\nquery GetTokenPrices($chains: [GqlChain!]!) {\n  tokenPrices: tokenGetCurrentPrices(chains: $chains) {\n    price\n    address\n    chain\n    updatedAt\n  }\n}\n\nquery GetTokensDynamicData($addresses: [String!]!) {\n  dynamicData: tokenGetTokensDynamicData(addresses: $addresses) {\n    ath\n    atl\n    fdv\n    high24h\n    id\n    low24h\n    marketCap\n    price\n    priceChange24h\n    priceChangePercent7d\n    priceChangePercent14d\n    priceChangePercent24h\n    priceChangePercent30d\n    tokenAddress\n    updatedAt\n  }\n}\n\nquery GetBlocksPerDay {\n  blocksPerDay: blocksGetBlocksPerDay\n  avgBlockTime: blocksGetAverageBlockTime\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment Hook on GqlHook {\n  address\n  config {\n    enableHookAdjustedAmounts\n    shouldCallAfterAddLiquidity\n    shouldCallAfterInitialize\n    shouldCallAfterRemoveLiquidity\n    shouldCallAfterSwap\n    shouldCallBeforeAddLiquidity\n    shouldCallBeforeInitialize\n    shouldCallBeforeRemoveLiquidity\n    shouldCallBeforeSwap\n    shouldCallComputeDynamicSwapFee\n  }\n  type\n  params {\n    ... on ExitFeeHookParams {\n      exitFeePercentage\n    }\n    ... on FeeTakingHookParams {\n      addLiquidityFeePercentage\n      removeLiquidityFeePercentage\n      swapFeePercentage\n    }\n    ... on StableSurgeHookParams {\n      maxSurgeFeePercentage\n      surgeThresholdPercentage\n    }\n    ... on MevTaxHookParams {\n      mevTaxThreshold\n      mevTaxMultiplier\n      maxMevSwapFeePercentage\n    }\n  }\n  reviewData {\n    reviewFile\n    summary\n    warnings\n  }\n}"): (typeof documents)["fragment Hook on GqlHook {\n  address\n  config {\n    enableHookAdjustedAmounts\n    shouldCallAfterAddLiquidity\n    shouldCallAfterInitialize\n    shouldCallAfterRemoveLiquidity\n    shouldCallAfterSwap\n    shouldCallBeforeAddLiquidity\n    shouldCallBeforeInitialize\n    shouldCallBeforeRemoveLiquidity\n    shouldCallBeforeSwap\n    shouldCallComputeDynamicSwapFee\n  }\n  type\n  params {\n    ... on ExitFeeHookParams {\n      exitFeePercentage\n    }\n    ... on FeeTakingHookParams {\n      addLiquidityFeePercentage\n      removeLiquidityFeePercentage\n      swapFeePercentage\n    }\n    ... on StableSurgeHookParams {\n      maxSurgeFeePercentage\n      surgeThresholdPercentage\n    }\n    ... on MevTaxHookParams {\n      mevTaxThreshold\n      mevTaxMultiplier\n      maxMevSwapFeePercentage\n    }\n  }\n  reviewData {\n    reviewFile\n    summary\n    warnings\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment UnderlyingToken on GqlToken {\n  chain\n  chainId\n  address\n  decimals\n  name\n  symbol\n  priority\n  tradable\n  isErc4626\n  logoURI\n}\n\nfragment Erc4626ReviewData on Erc4626ReviewData {\n  reviewFile\n  summary\n  warnings\n}\n\nfragment PoolTokens on GqlPoolTokenDetail {\n  id\n  chain\n  chainId\n  address\n  decimals\n  name\n  symbol\n  priority\n  tradable\n  canUseBufferForSwaps\n  useWrappedForAddRemove\n  useUnderlyingForAddRemove\n  index\n  balance\n  balanceUSD\n  priceRate\n  decimals\n  weight\n  hasNestedPool\n  isAllowed\n  priceRateProvider\n  logoURI\n  priceRateProviderData {\n    address\n    name\n    summary\n    reviewed\n    warnings\n    upgradeableComponents {\n      entryPoint\n      implementationReviewed\n    }\n    reviewFile\n    factory\n  }\n  nestedPool {\n    id\n    address\n    type\n    bptPriceRate\n    nestedPercentage\n    nestedShares\n    totalLiquidity\n    totalShares\n    tokens {\n      index\n      address\n      decimals\n      balance\n      balanceUSD\n      symbol\n      weight\n      isErc4626\n      canUseBufferForSwaps\n      useWrappedForAddRemove\n      useUnderlyingForAddRemove\n      logoURI\n      underlyingToken {\n        ...UnderlyingToken\n      }\n      erc4626ReviewData {\n        ...Erc4626ReviewData\n      }\n    }\n    hook {\n      ...Hook\n    }\n  }\n  isErc4626\n  isBufferAllowed\n  underlyingToken {\n    ...UnderlyingToken\n  }\n  erc4626ReviewData {\n    ...Erc4626ReviewData\n  }\n}"): (typeof documents)["fragment UnderlyingToken on GqlToken {\n  chain\n  chainId\n  address\n  decimals\n  name\n  symbol\n  priority\n  tradable\n  isErc4626\n  logoURI\n}\n\nfragment Erc4626ReviewData on Erc4626ReviewData {\n  reviewFile\n  summary\n  warnings\n}\n\nfragment PoolTokens on GqlPoolTokenDetail {\n  id\n  chain\n  chainId\n  address\n  decimals\n  name\n  symbol\n  priority\n  tradable\n  canUseBufferForSwaps\n  useWrappedForAddRemove\n  useUnderlyingForAddRemove\n  index\n  balance\n  balanceUSD\n  priceRate\n  decimals\n  weight\n  hasNestedPool\n  isAllowed\n  priceRateProvider\n  logoURI\n  priceRateProviderData {\n    address\n    name\n    summary\n    reviewed\n    warnings\n    upgradeableComponents {\n      entryPoint\n      implementationReviewed\n    }\n    reviewFile\n    factory\n  }\n  nestedPool {\n    id\n    address\n    type\n    bptPriceRate\n    nestedPercentage\n    nestedShares\n    totalLiquidity\n    totalShares\n    tokens {\n      index\n      address\n      decimals\n      balance\n      balanceUSD\n      symbol\n      weight\n      isErc4626\n      canUseBufferForSwaps\n      useWrappedForAddRemove\n      useUnderlyingForAddRemove\n      logoURI\n      underlyingToken {\n        ...UnderlyingToken\n      }\n      erc4626ReviewData {\n        ...Erc4626ReviewData\n      }\n    }\n    hook {\n      ...Hook\n    }\n  }\n  isErc4626\n  isBufferAllowed\n  underlyingToken {\n    ...UnderlyingToken\n  }\n  erc4626ReviewData {\n    ...Erc4626ReviewData\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetPool($id: String!, $chain: GqlChain!, $userAddress: String) {\n  pool: poolGetPool(id: $id, chain: $chain, userAddress: $userAddress) {\n    id\n    address\n    name\n    version\n    owner\n    swapFeeManager\n    pauseManager\n    poolCreator\n    decimals\n    factory\n    symbol\n    createTime\n    type\n    chain\n    protocolVersion\n    tags\n    hasErc4626\n    hasNestedErc4626\n    liquidityManagement {\n      disableUnbalancedLiquidity\n    }\n    hook {\n      ...Hook\n    }\n    dynamicData {\n      poolId\n      swapEnabled\n      totalLiquidity\n      totalShares\n      fees24h\n      surplus24h\n      swapFee\n      volume24h\n      holdersCount\n      isInRecoveryMode\n      isPaused\n      aprItems {\n        id\n        title\n        apr\n        type\n        rewardTokenSymbol\n        rewardTokenAddress\n      }\n    }\n    staking {\n      id\n      type\n      chain\n      address\n      gauge {\n        id\n        gaugeAddress\n        version\n        status\n        workingSupply\n        otherGauges {\n          gaugeAddress\n          version\n          status\n          id\n          rewards {\n            id\n            tokenAddress\n            rewardPerSecond\n          }\n        }\n        rewards {\n          id\n          rewardPerSecond\n          tokenAddress\n        }\n      }\n      aura {\n        id\n        apr\n        auraPoolAddress\n        auraPoolId\n        isShutdown\n      }\n    }\n    userBalance {\n      totalBalance\n      totalBalanceUsd\n      walletBalance\n      walletBalanceUsd\n      stakedBalances {\n        balance\n        balanceUsd\n        stakingType\n        stakingId\n      }\n    }\n    ... on GqlPoolWeighted {\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolStable {\n      amp\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolMetaStable {\n      amp\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolElement {\n      unitSeconds\n      principalToken\n      baseToken\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolComposableStable {\n      amp\n      nestingType\n      bptPriceRate\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolLiquidityBootstrapping {\n      name\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolGyro {\n      alpha\n      beta\n      type\n      c\n      dSq\n      lambda\n      root3Alpha\n      s\n      sqrtAlpha\n      sqrtBeta\n      tauAlphaX\n      tauAlphaY\n      tauBetaX\n      tauBetaY\n      u\n      v\n      w\n      z\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolFx {\n      alpha\n      beta\n      delta\n      epsilon\n      lambda\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolQuantAmmWeighted {\n      hasAnyAllowedBuffer\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolReClamm {\n      hasAnyAllowedBuffer\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n  }\n}\n\nquery GetPoolSnapshots($poolId: String!, $range: GqlPoolSnapshotDataRange!, $chainId: GqlChain!) {\n  snapshots: poolGetSnapshots(id: $poolId, range: $range, chain: $chainId) {\n    id\n    timestamp\n    totalLiquidity\n    volume24h\n    fees24h\n    surplus24h\n    sharePrice\n  }\n}\n\nquery GetPoolTokensDynamicData($addresses: [String!]!) {\n  staticData: tokenGetTokensData(addresses: $addresses) {\n    id\n    tokenAddress\n    description\n    discordUrl\n    telegramUrl\n    twitterUsername\n    websiteUrl\n  }\n  dynamicData: tokenGetTokensDynamicData(addresses: $addresses) {\n    ...GqlTokenDynamicData\n  }\n}\n\nquery GetPoolEvents($first: Int, $skip: Int, $poolIdIn: [String!]!, $chainIn: [GqlChain!]!, $range: GqlPoolEventsDataRange, $typeIn: [GqlPoolEventType], $userAddress: String) {\n  poolEvents(\n    first: $first\n    skip: $skip\n    where: {poolIdIn: $poolIdIn, chainIn: $chainIn, range: $range, typeIn: $typeIn, userAddress: $userAddress}\n  ) {\n    id\n    poolId\n    timestamp\n    tx\n    type\n    valueUSD\n    chain\n    userAddress\n    ... on GqlPoolSwapEventV3 {\n      tokenIn {\n        address\n        amount\n      }\n      tokenOut {\n        address\n        amount\n      }\n    }\n    ... on GqlPoolSwapEventCowAmm {\n      tokenIn {\n        address\n        amount\n        valueUSD\n      }\n      tokenOut {\n        address\n        amount\n        valueUSD\n      }\n      surplus {\n        address\n        amount\n        valueUSD\n      }\n    }\n    ... on GqlPoolAddRemoveEventV3 {\n      tokens {\n        address\n        amount\n        valueUSD\n      }\n    }\n  }\n}"): (typeof documents)["query GetPool($id: String!, $chain: GqlChain!, $userAddress: String) {\n  pool: poolGetPool(id: $id, chain: $chain, userAddress: $userAddress) {\n    id\n    address\n    name\n    version\n    owner\n    swapFeeManager\n    pauseManager\n    poolCreator\n    decimals\n    factory\n    symbol\n    createTime\n    type\n    chain\n    protocolVersion\n    tags\n    hasErc4626\n    hasNestedErc4626\n    liquidityManagement {\n      disableUnbalancedLiquidity\n    }\n    hook {\n      ...Hook\n    }\n    dynamicData {\n      poolId\n      swapEnabled\n      totalLiquidity\n      totalShares\n      fees24h\n      surplus24h\n      swapFee\n      volume24h\n      holdersCount\n      isInRecoveryMode\n      isPaused\n      aprItems {\n        id\n        title\n        apr\n        type\n        rewardTokenSymbol\n        rewardTokenAddress\n      }\n    }\n    staking {\n      id\n      type\n      chain\n      address\n      gauge {\n        id\n        gaugeAddress\n        version\n        status\n        workingSupply\n        otherGauges {\n          gaugeAddress\n          version\n          status\n          id\n          rewards {\n            id\n            tokenAddress\n            rewardPerSecond\n          }\n        }\n        rewards {\n          id\n          rewardPerSecond\n          tokenAddress\n        }\n      }\n      aura {\n        id\n        apr\n        auraPoolAddress\n        auraPoolId\n        isShutdown\n      }\n    }\n    userBalance {\n      totalBalance\n      totalBalanceUsd\n      walletBalance\n      walletBalanceUsd\n      stakedBalances {\n        balance\n        balanceUsd\n        stakingType\n        stakingId\n      }\n    }\n    ... on GqlPoolWeighted {\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolStable {\n      amp\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolMetaStable {\n      amp\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolElement {\n      unitSeconds\n      principalToken\n      baseToken\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolComposableStable {\n      amp\n      nestingType\n      bptPriceRate\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolLiquidityBootstrapping {\n      name\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolGyro {\n      alpha\n      beta\n      type\n      c\n      dSq\n      lambda\n      root3Alpha\n      s\n      sqrtAlpha\n      sqrtBeta\n      tauAlphaX\n      tauAlphaY\n      tauBetaX\n      tauBetaY\n      u\n      v\n      w\n      z\n      nestingType\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolFx {\n      alpha\n      beta\n      delta\n      epsilon\n      lambda\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolQuantAmmWeighted {\n      hasAnyAllowedBuffer\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n    ... on GqlPoolReClamm {\n      hasAnyAllowedBuffer\n      poolTokens {\n        ...PoolTokens\n      }\n    }\n  }\n}\n\nquery GetPoolSnapshots($poolId: String!, $range: GqlPoolSnapshotDataRange!, $chainId: GqlChain!) {\n  snapshots: poolGetSnapshots(id: $poolId, range: $range, chain: $chainId) {\n    id\n    timestamp\n    totalLiquidity\n    volume24h\n    fees24h\n    surplus24h\n    sharePrice\n  }\n}\n\nquery GetPoolTokensDynamicData($addresses: [String!]!) {\n  staticData: tokenGetTokensData(addresses: $addresses) {\n    id\n    tokenAddress\n    description\n    discordUrl\n    telegramUrl\n    twitterUsername\n    websiteUrl\n  }\n  dynamicData: tokenGetTokensDynamicData(addresses: $addresses) {\n    ...GqlTokenDynamicData\n  }\n}\n\nquery GetPoolEvents($first: Int, $skip: Int, $poolIdIn: [String!]!, $chainIn: [GqlChain!]!, $range: GqlPoolEventsDataRange, $typeIn: [GqlPoolEventType], $userAddress: String) {\n  poolEvents(\n    first: $first\n    skip: $skip\n    where: {poolIdIn: $poolIdIn, chainIn: $chainIn, range: $range, typeIn: $typeIn, userAddress: $userAddress}\n  ) {\n    id\n    poolId\n    timestamp\n    tx\n    type\n    valueUSD\n    chain\n    userAddress\n    ... on GqlPoolSwapEventV3 {\n      tokenIn {\n        address\n        amount\n      }\n      tokenOut {\n        address\n        amount\n      }\n    }\n    ... on GqlPoolSwapEventCowAmm {\n      tokenIn {\n        address\n        amount\n        valueUSD\n      }\n      tokenOut {\n        address\n        amount\n        valueUSD\n      }\n      surplus {\n        address\n        amount\n        valueUSD\n      }\n    }\n    ... on GqlPoolAddRemoveEventV3 {\n      tokens {\n        address\n        amount\n        valueUSD\n      }\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetPools($first: Int, $skip: Int, $orderBy: GqlPoolOrderBy, $orderDirection: GqlPoolOrderDirection, $where: GqlPoolFilter, $textSearch: String) {\n  pools: poolGetPools(\n    first: $first\n    skip: $skip\n    orderBy: $orderBy\n    orderDirection: $orderDirection\n    where: $where\n    textSearch: $textSearch\n  ) {\n    address\n    chain\n    createTime\n    decimals\n    protocolVersion\n    tags\n    hasErc4626\n    hasNestedErc4626\n    hook {\n      ...Hook\n    }\n    poolTokens {\n      id\n      address\n      symbol\n      weight\n      name\n      canUseBufferForSwaps\n      useWrappedForAddRemove\n      useUnderlyingForAddRemove\n      nestedPool {\n        id\n        address\n        symbol\n        name\n        tokens {\n          id\n          address\n          symbol\n          weight\n          name\n          canUseBufferForSwaps\n          useWrappedForAddRemove\n          useUnderlyingForAddRemove\n        }\n      }\n    }\n    dynamicData {\n      totalLiquidity\n      lifetimeVolume\n      lifetimeSwapFees\n      volume24h\n      fees24h\n      holdersCount\n      swapFee\n      swapsCount\n      totalShares\n      aprItems {\n        id\n        title\n        apr\n        type\n        rewardTokenSymbol\n        rewardTokenAddress\n      }\n    }\n    staking {\n      id\n      type\n      chain\n      address\n      gauge {\n        id\n        gaugeAddress\n        version\n        status\n        workingSupply\n        otherGauges {\n          gaugeAddress\n          version\n          status\n          id\n          rewards {\n            id\n            tokenAddress\n            rewardPerSecond\n          }\n        }\n        rewards {\n          id\n          rewardPerSecond\n          tokenAddress\n        }\n      }\n      aura {\n        id\n        apr\n        auraPoolAddress\n        auraPoolId\n        isShutdown\n      }\n    }\n    factory\n    id\n    name\n    owner\n    swapFeeManager\n    pauseManager\n    poolCreator\n    symbol\n    type\n    userBalance {\n      totalBalance\n      totalBalanceUsd\n      walletBalance\n      walletBalanceUsd\n      stakedBalances {\n        balance\n        balanceUsd\n        stakingType\n        stakingId\n      }\n    }\n    poolTokens {\n      ...PoolTokens\n    }\n  }\n  count: poolGetPoolsCount(\n    first: $first\n    skip: $skip\n    orderBy: $orderBy\n    orderDirection: $orderDirection\n    where: $where\n    textSearch: $textSearch\n  )\n}\n\nquery GetFeaturedPools($chains: [GqlChain!]!) {\n  featuredPools: poolGetFeaturedPools(chains: $chains) {\n    poolId\n    primary\n    description\n    pool {\n      address\n      id\n      name\n      factory\n      symbol\n      type\n      chain\n      protocolVersion\n      dynamicData {\n        totalLiquidity\n        aprItems {\n          id\n          title\n          apr\n          type\n          rewardTokenSymbol\n          rewardTokenAddress\n        }\n      }\n      poolTokens {\n        ...PoolTokens\n      }\n      hasErc4626\n      hasNestedErc4626\n    }\n  }\n}"): (typeof documents)["query GetPools($first: Int, $skip: Int, $orderBy: GqlPoolOrderBy, $orderDirection: GqlPoolOrderDirection, $where: GqlPoolFilter, $textSearch: String) {\n  pools: poolGetPools(\n    first: $first\n    skip: $skip\n    orderBy: $orderBy\n    orderDirection: $orderDirection\n    where: $where\n    textSearch: $textSearch\n  ) {\n    address\n    chain\n    createTime\n    decimals\n    protocolVersion\n    tags\n    hasErc4626\n    hasNestedErc4626\n    hook {\n      ...Hook\n    }\n    poolTokens {\n      id\n      address\n      symbol\n      weight\n      name\n      canUseBufferForSwaps\n      useWrappedForAddRemove\n      useUnderlyingForAddRemove\n      nestedPool {\n        id\n        address\n        symbol\n        name\n        tokens {\n          id\n          address\n          symbol\n          weight\n          name\n          canUseBufferForSwaps\n          useWrappedForAddRemove\n          useUnderlyingForAddRemove\n        }\n      }\n    }\n    dynamicData {\n      totalLiquidity\n      lifetimeVolume\n      lifetimeSwapFees\n      volume24h\n      fees24h\n      holdersCount\n      swapFee\n      swapsCount\n      totalShares\n      aprItems {\n        id\n        title\n        apr\n        type\n        rewardTokenSymbol\n        rewardTokenAddress\n      }\n    }\n    staking {\n      id\n      type\n      chain\n      address\n      gauge {\n        id\n        gaugeAddress\n        version\n        status\n        workingSupply\n        otherGauges {\n          gaugeAddress\n          version\n          status\n          id\n          rewards {\n            id\n            tokenAddress\n            rewardPerSecond\n          }\n        }\n        rewards {\n          id\n          rewardPerSecond\n          tokenAddress\n        }\n      }\n      aura {\n        id\n        apr\n        auraPoolAddress\n        auraPoolId\n        isShutdown\n      }\n    }\n    factory\n    id\n    name\n    owner\n    swapFeeManager\n    pauseManager\n    poolCreator\n    symbol\n    type\n    userBalance {\n      totalBalance\n      totalBalanceUsd\n      walletBalance\n      walletBalanceUsd\n      stakedBalances {\n        balance\n        balanceUsd\n        stakingType\n        stakingId\n      }\n    }\n    poolTokens {\n      ...PoolTokens\n    }\n  }\n  count: poolGetPoolsCount(\n    first: $first\n    skip: $skip\n    orderBy: $orderBy\n    orderDirection: $orderDirection\n    where: $where\n    textSearch: $textSearch\n  )\n}\n\nquery GetFeaturedPools($chains: [GqlChain!]!) {\n  featuredPools: poolGetFeaturedPools(chains: $chains) {\n    poolId\n    primary\n    description\n    pool {\n      address\n      id\n      name\n      factory\n      symbol\n      type\n      chain\n      protocolVersion\n      dynamicData {\n        totalLiquidity\n        aprItems {\n          id\n          title\n          apr\n          type\n          rewardTokenSymbol\n          rewardTokenAddress\n        }\n      }\n      poolTokens {\n        ...PoolTokens\n      }\n      hasErc4626\n      hasNestedErc4626\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetProtocolStats($chains: [GqlChain!]) {\n  protocolMetricsAggregated(chains: $chains) {\n    totalLiquidity\n    numLiquidityProviders\n    swapVolume24h\n    swapFee24h\n    yieldCapture24h\n    poolCount\n    yieldCapture24h\n    surplus24h\n  }\n}\n\nquery GetProtocolStatsPerChain($chain: GqlChain) {\n  protocolMetricsChain(chain: $chain) {\n    chainId\n    numLiquidityProviders\n    poolCount\n    swapFee24h\n    swapVolume24h\n    totalLiquidity\n    yieldCapture24h\n    surplus24h\n  }\n}"): (typeof documents)["query GetProtocolStats($chains: [GqlChain!]) {\n  protocolMetricsAggregated(chains: $chains) {\n    totalLiquidity\n    numLiquidityProviders\n    swapVolume24h\n    swapFee24h\n    yieldCapture24h\n    poolCount\n    yieldCapture24h\n    surplus24h\n  }\n}\n\nquery GetProtocolStatsPerChain($chain: GqlChain) {\n  protocolMetricsChain(chain: $chain) {\n    chainId\n    numLiquidityProviders\n    poolCount\n    swapFee24h\n    swapVolume24h\n    totalLiquidity\n    yieldCapture24h\n    surplus24h\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetReliquaryFarmSnapshots($id: String!, $range: GqlPoolSnapshotDataRange!) {\n  snapshots: beetsPoolGetReliquaryFarmSnapshots(id: $id, range: $range) {\n    id\n    farmId\n    timestamp\n    totalBalance\n    totalLiquidity\n    levelBalances {\n      id\n      level\n      balance\n    }\n    relicCount\n    totalBalance\n    userCount\n    tokenBalances {\n      id\n      address\n      balance\n      symbol\n    }\n  }\n}"): (typeof documents)["query GetReliquaryFarmSnapshots($id: String!, $range: GqlPoolSnapshotDataRange!) {\n  snapshots: beetsPoolGetReliquaryFarmSnapshots(id: $id, range: $range) {\n    id\n    farmId\n    timestamp\n    totalBalance\n    totalLiquidity\n    levelBalances {\n      id\n      level\n      balance\n    }\n    relicCount\n    totalBalance\n    userCount\n    tokenBalances {\n      id\n      address\n      balance\n      symbol\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetStakedSonicData {\n  stsGetGqlStakedSonicData {\n    delegatedValidators {\n      assetsDelegated\n      validatorId\n    }\n    exchangeRate\n    stakingApr\n    totalAssets\n    totalAssetsDelegated\n    totalAssetsPool\n    rewardsClaimed24h\n  }\n}"): (typeof documents)["query GetStakedSonicData {\n  stsGetGqlStakedSonicData {\n    delegatedValidators {\n      assetsDelegated\n      validatorId\n    }\n    exchangeRate\n    stakingApr\n    totalAssets\n    totalAssetsDelegated\n    totalAssetsPool\n    rewardsClaimed24h\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query SorGetSwapPaths($tokenIn: String!, $tokenOut: String!, $swapType: GqlSorSwapType!, $swapAmount: AmountHumanReadable!, $chain: GqlChain!, $poolIds: [String!]) {\n  swaps: sorGetSwapPaths(\n    tokenIn: $tokenIn\n    tokenOut: $tokenOut\n    swapType: $swapType\n    swapAmount: $swapAmount\n    chain: $chain\n    poolIds: $poolIds\n    considerPoolsWithHooks: true\n  ) {\n    effectivePrice\n    effectivePriceReversed\n    swapType\n    paths {\n      inputAmountRaw\n      outputAmountRaw\n      pools\n      isBuffer\n      protocolVersion\n      tokens {\n        address\n        decimals\n      }\n    }\n    priceImpact {\n      priceImpact\n      error\n    }\n    returnAmount\n    routes {\n      hops {\n        poolId\n        tokenIn\n        tokenInAmount\n        tokenOut\n        tokenOutAmount\n      }\n      share\n      tokenInAmount\n      tokenInAmount\n      tokenOut\n      tokenOutAmount\n    }\n    swapAmount\n    swaps {\n      amount\n      assetInIndex\n      assetOutIndex\n      poolId\n      userData\n    }\n    tokenIn\n    tokenInAmount\n    tokenOut\n    tokenOutAmount\n    protocolVersion\n  }\n}\n\nfragment GqlTokenDynamicData on GqlTokenDynamicData {\n  id\n  tokenAddress\n  ath\n  atl\n  marketCap\n  fdv\n  priceChange24h\n  priceChangePercent24h\n  priceChangePercent7d\n  priceChangePercent14d\n  priceChangePercent30d\n  high24h\n  low24h\n  updatedAt\n}"): (typeof documents)["query SorGetSwapPaths($tokenIn: String!, $tokenOut: String!, $swapType: GqlSorSwapType!, $swapAmount: AmountHumanReadable!, $chain: GqlChain!, $poolIds: [String!]) {\n  swaps: sorGetSwapPaths(\n    tokenIn: $tokenIn\n    tokenOut: $tokenOut\n    swapType: $swapType\n    swapAmount: $swapAmount\n    chain: $chain\n    poolIds: $poolIds\n    considerPoolsWithHooks: true\n  ) {\n    effectivePrice\n    effectivePriceReversed\n    swapType\n    paths {\n      inputAmountRaw\n      outputAmountRaw\n      pools\n      isBuffer\n      protocolVersion\n      tokens {\n        address\n        decimals\n      }\n    }\n    priceImpact {\n      priceImpact\n      error\n    }\n    returnAmount\n    routes {\n      hops {\n        poolId\n        tokenIn\n        tokenInAmount\n        tokenOut\n        tokenOutAmount\n      }\n      share\n      tokenInAmount\n      tokenInAmount\n      tokenOut\n      tokenOutAmount\n    }\n    swapAmount\n    swaps {\n      amount\n      assetInIndex\n      assetOutIndex\n      poolId\n      userData\n    }\n    tokenIn\n    tokenInAmount\n    tokenOut\n    tokenOutAmount\n    protocolVersion\n  }\n}\n\nfragment GqlTokenDynamicData on GqlTokenDynamicData {\n  id\n  tokenAddress\n  ath\n  atl\n  marketCap\n  fdv\n  priceChange24h\n  priceChangePercent24h\n  priceChangePercent7d\n  priceChangePercent14d\n  priceChangePercent30d\n  high24h\n  low24h\n  updatedAt\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetVeBalUser($address: String!, $chain: GqlChain) {\n  veBalGetUser(address: $address, chain: $chain) {\n    balance\n    rank\n    lockSnapshots {\n      balance\n      timestamp\n      bias\n      slope\n    }\n  }\n}"): (typeof documents)["query GetVeBalUser($address: String!, $chain: GqlChain) {\n  veBalGetUser(address: $address, chain: $chain) {\n    balance\n    rank\n    lockSnapshots {\n      balance\n      timestamp\n      bias\n      slope\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetVeBalVotingList($includeKilled: Boolean) {\n  veBalGetVotingList(includeKilled: $includeKilled) {\n    id\n    symbol\n    type\n    address\n    chain\n    protocolVersion\n    gauge {\n      addedTimestamp\n      address\n      childGaugeAddress\n      isKilled\n      relativeWeight\n      relativeWeightCap\n    }\n    poolTokens {\n      ...PoolTokens\n    }\n    tags\n  }\n}"): (typeof documents)["query GetVeBalVotingList($includeKilled: Boolean) {\n  veBalGetVotingList(includeKilled: $includeKilled) {\n    id\n    symbol\n    type\n    address\n    chain\n    protocolVersion\n    gauge {\n      addedTimestamp\n      address\n      childGaugeAddress\n      isKilled\n      relativeWeight\n      relativeWeightCap\n    }\n    poolTokens {\n      ...PoolTokens\n    }\n    tags\n  }\n}"];

export function graphql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;